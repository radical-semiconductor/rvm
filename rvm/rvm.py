#!/usr/bin/env python3

from abc import ABC, abstractmethod
from copy import copy
from pyverilator import PyVerilator
from queue import Queue

############################################################################

class RVMDatabase(PyVerilator):
    pass

class RVMObject(ABC):
    pass

class RVMComponent(RVMObject):
    pass

class RVMAgent:
    pass

class RVMDriver(RVMComponent):
    pass

class RVMMonitor(RVMComponent):
    pass

class RVMSequencer(RVMObject):
    pass

class RVMTransaction:
    pass

############################################################################

class RVMObject(ABC):
    """
    Base class for various classes, such as components.
    """
    def __init__(self, rvm : RVMDatabase):
        """
        Initializer.

        :param rvm: RVMDatabase for given DUT
        """
        self.rvm = rvm
    @property
    def time(self):
        """
        Return the simulation time.
        """
        return self.rvm.curr_time
    def snoop(self, signame : str):
        """
        Get an interface signal's value from the DUT.

        :param signame: name of the signal
        """
        return eval(f"self.rvm.io.{signame}.value")
    @abstractmethod
    def body(self):
        """
        To be executed on each rising clock edge.
        """
        pass
    @abstractmethod
    def done(self):
        """
        Tells the user if there are any pending transactions
        """
        pass

class RVMComponent(RVMObject):
    """
    Base class for classes that directly interface with the DUT, such as drivers and monitors.
    RVMComponents contain transaction queues.
    """
    def __init__(self, *args, **kwargs):
        """
        Initializer.
        """
        super().__init__(*args, **kwargs)
        self.input_trans_q = Queue()
        self.input_trans = None
        self.trans_done = True
    def toggle_trans_done(self):
        """
        If the transaction is done, then switch trans_done to False.
        If the transaction is not done, then switch trans_done to True.
        """
        self.trans_done = not self.trans_done
    def pre_body(self):
        """
        Function called prior to the body. Grabs a new transaction if one is available.
        """
        if self.trans_done == True:
            self.get_new_trans()
    def get_new_trans(self):
        """
        Grab a new transaction if one is available.
        """
        if self.input_trans_q.qsize() > 0:
            self.input_trans = self.input_trans_q.get()
            self.trans_done = False
    def push(self, trans : RVMTransaction):
        """
        Push transaction to queue.

        :param trans: Transaction to push
        """
        self.input_trans_q.put(trans)
    def done(self):
        """
        Tells the user if there are any pending transactions. False
        if the queue is nonempty.
        """
        return self.input_trans_q.qsize() == 0
    @property
    def num_pending_trans(self):
        """
        Number of pending transactions (i.e. number of entries in
        queue)
        """
        return self.input_trans_q.qsize()

class RVMSequencer(RVMObject):
    """
    Generate transactions and broadcast to target components'
    queues.
    """
    def __init__(self, rvm            : RVMDatabase, \
                       rvm_trans_type : RVMTransaction, \
                       targets        : list[RVMComponent], \
                       num_trans      : int = 50, **kwargs):
        """
        Initializer
        
        :param rvm: RVMDatabase for given DUT
        :param rvm_trans_type: type of generated transactions; must be a child of RVMTransaction
        :param targets: list of component objects to which transactions are to be broadcast on each cycle
        :param num_trans: number of transaction generated by sequencer during simulation
        """
        super().__init__(rvm, **kwargs)
        self.rvm.register_sequencer(self)
        self.rvm_trans_type = rvm_trans_type
        self.trans = self.rvm_trans_type(self.rvm)
        self.targets = targets
        self.num_trans = num_trans
        self.curr_num_trans = 0
        self.__randomize = self.trans.randomize()
    def _randomize(self):
        """
        Internal method for randomizing transaction object
        """
        try:
            next(self.__randomize)
        except StopIteration:
            self.__randomize = self.trans.randomize()
            next(self.__randomize)
    def _next_trans(self):
        """
        Internal method for creating and returning new randomized object
        """
        self._randomize()
        return copy(self.trans)
    def body(self):
        """
        To be executed on each rising clock edge. The body of a
        sequencer is meant to generate a randomized transaction
        and broadcast it to the target components
        """
        if self.curr_num_trans < self.num_trans:
            print(f"trans = {self.curr_num_trans}")
            tmp_trans = self._next_trans()
            for _ in self.targets:
                _.push(tmp_trans) # TODO: why does directly accessing input_trans_q cause an error?
            self.curr_num_trans += 1
        yield # DO NOT REMOVE
    def done(self):
        """
        Tells the user if there are any pending transactions
        """
        return self.curr_num_trans == self.num_trans

class RVMTransaction:
    """
    Abstract transaction class used to generate input stimulus for the DUT.
    """
    def __init__(self, rvm : RVMDatabase):
        """
        Initializer
        
        :param rvm: The RVMDatabase object corresponding to the DUT.
        """
        self.rvm = rvm
        get_width = lambda self,_ : eval(f"self.rvm.io.{_}.signal.width")
        self.widths = {_:get_width(self,_) for _ in dir(self.rvm.io)}
        self.inputs = [_[0] for _ in self.rvm.inputs if _[0] != rvm.clock.short_name]
        self.outputs = [_[0] for _ in self.rvm.outputs]
        self.trans = dict(zip(self.inputs, [0]*len(self.inputs)))
    @abstractmethod
    def randomize(self):
        """
        Randomize the self.trans dictionary. The most basic self.trans dictionary maps input signal names to values.
        However, the self.trans dictionary can be any arbitrary dictionary, so long as monitors and drivers are
        written to interpret them properly.
        """
        yield

class RVMDriver(RVMComponent):
    """
    Drive signals to the interface of the DUT based on transaction.
    """
    def __init__(self, *args, **kwargs):
        """
        Initializer
        """
        super().__init__(*args, **kwargs)
        self.rvm.register_driver(self)
    def drive(self, signame : str, value : int):
        """
        Drive 'value' on DUT signal named 'signame'.

        :param signame: name of the signal to be driven
        :param value: value to be driven
        """
        exec(f"self.rvm.io.{signame}.signal.write({value})")
    def body(self):
        """
        To be executed on each rising clock edge. The body of a
        driver is meant to set the signals on the DUT for a single
        transaction.
        """
        # Body handles a single transaction
        self.pre_body() # DO NOT REMOVE
        for (k,v) in self.input_trans.trans.items():
            exec(f"self.rvm.io.{k}.signal.write({v})")
        self.toggle_trans_done()
        yield # DO NOT REMOVE

class RVMMonitor(RVMComponent):
    """
    Record and check signals on the interface of the DUT.
    """
    def __init__(self, *args, **kwargs):
        """
        Initializer.
        """
        super().__init__(*args, **kwargs)
        self.rvm.register_monitor(self)
    def body(self):
        """
        To be executed on each rising clock edge. The body of a
        driver is meant to record and check output signals for a single
        transaction.
        """
        self.pre_body() # DO NOT REMOVE
        self.toggle_trans_done()
        yield # DO NOT REMOVE

class RVMDatabase(PyVerilator):
    """
    Central class of RVM. Serves as a database for tracking different testbench
    components as well as a wrapper around the DUT. Note that all DUTs are assumed
    to be clocked and have no purely combinational paths from input to output.
    """
    def __init__(self, *args, **kwargs):
        """
        Initializer.
        """
        super().__init__(*args, **kwargs)
        self.timesteps = 100000
        self.objects = []
        self.monitors = {}
        self.drivers = {}
        self.sequencers = {}
        self.start_vcd_trace("dump.vcd")
    def register_driver(self, o : RVMDriver):
        """
        Register driver component with the database.

        :param o: RVMDriver object
        """
        self.objects.append(o)
        self.drivers[o] = o.body()
    def register_sequencer(self, o : RVMSequencer):
        """
        Register sequencer component with the database.

        :param o: RVMSequencer object
        """
        self.objects.append(o)
        self.sequencers[o] = o.body()
    def register_monitor(self, o : RVMMonitor):
        """
        Register monitor component with the database.

        :param o: RVMMonitor object
        """
        self.objects.append(o)
        self.monitors[o] = o.body()
    def mainloop(self):
        """
        Main simulation loop. On rising clock edge, the order
        in which objects evaluate is:

        1. Monitors
        2. Sequencers
        3. Drivers
        """
        # Start clock at zero
        self.clock.write(0)
        self.do_sequencers()
        self.do_drivers()
        self.clock.write(1)
        for t in range(self.timesteps):
            if self.done() == True:
                self.finished = 1 # dumps coverage.dat
                return 0
            else:
                self.do_monitors()
                self.do_sequencers()
                self.do_drivers()
                self.clock.tick()
        self.finished = 1 # dumps coverage.dat
        return 1
    def done(self):
        """
        Check to see that no registered objects have pending transactions.
        """
        return all([_.done() for _ in self.objects])
    def do_monitors(self):
        """
        Evaluate the body of all monitors.
        """
        for (k,v) in self.monitors.items():
            try:
                next(v)
            except StopIteration:
                self.monitors[k] = k.body()
                next(self.monitors[k])
    def do_drivers(self):
        """
        Evaluate the body of all drivers.
        """
        for (k,v) in self.drivers.items():
            try:
                next(v)
            except StopIteration:
                self.drivers[k] = k.body()
                next(self.drivers[k])
    def do_sequencers(self):
        """
        Evaluate the body of all sequencers.
        """
        for (k,v) in self.sequencers.items():
            try:
                next(v)
            except StopIteration:
                self.sequencers[k] = k.body()
                next(self.sequencers[k])

class RVMAgent:
    """
    The agent contains the driver, monitor, and transactions for a particular DUT.
    """
    def __init__(self, rvm : RVMDatabase, drv_class=[RVMDriver], \
                              mon_class=[RVMMonitor], \
                              itrans_class=RVMTransaction, \
                              num_trans=50):
        """
        Initializer
        
        :param rvm: RVMDatabase for given DUT
        :param drv_class: list of classes for the drivers; each provided class must be a child of RVMDriver.
        :param mon_class: list of classes for the monitors; each provided class must be a child of RVMMonitor.
        :param itrans_class: Class for the input transaction;
                             must be a child of RVMTransaction.
        :param num_trans: Number of transactions to be driven during test
        """
        self.rvm = rvm
        self.mon = [_(self.rvm) for _ in mon_class]
        self.drv = [_(self.rvm) for _ in drv_class]
        self.sqr = RVMSequencer(self.rvm, itrans_class, self.mon + self.drv, num_trans=num_trans)
